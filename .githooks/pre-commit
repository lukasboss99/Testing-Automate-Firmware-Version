#!/bin/sh
# =============================================================================
# Pre-Commit Hook: Auto-Increment Patch Version
# =============================================================================
# This hook automatically increments the patch number in the VERSION file
# only for commits on the development branch. The VERSION file is the single
# source of truth for the project version.
#
# Setup (run once per clone):
#   git config core.hooksPath .githooks
#
# To skip auto-increment for a single commit:
#   git commit --no-verify
# =============================================================================

REPO_ROOT="$(git rev-parse --show-toplevel)"
VERSION_FILE="$REPO_ROOT/VERSION"
CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"

# Only bump version on development branch commits
if [ "$CURRENT_BRANCH" != "development" ]; then
    exit 0
fi

version_gt() {
    IFS='.' read -r a_major a_minor a_patch <<EOF
$1
EOF
    IFS='.' read -r b_major b_minor b_patch <<EOF
$2
EOF

    if [ "$a_major" -gt "$b_major" ]; then return 0; fi
    if [ "$a_major" -lt "$b_major" ]; then return 1; fi
    if [ "$a_minor" -gt "$b_minor" ]; then return 0; fi
    if [ "$a_minor" -lt "$b_minor" ]; then return 1; fi
    if [ "$a_patch" -gt "$b_patch" ]; then return 0; fi
    return 1
}

is_valid_semver() {
    echo "$1" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'
}

# Create VERSION file if it doesn't exist
if [ ! -f "$VERSION_FILE" ]; then
    echo "0.0.1" > "$VERSION_FILE"
    echo "[version-hook] Created VERSION file with 0.0.1"
fi

# Check if there are actual staged changes (excluding VERSION itself)
STAGED_CHANGES=$(git diff --cached --name-only | grep -v "^VERSION$")
if [ -z "$STAGED_CHANGES" ]; then
    # Only VERSION is staged or nothing is staged â€” don't increment
    exit 0
fi

# Read current version
VERSION=$(tr -d '[:space:]' < "$VERSION_FILE")

# Parse and validate version format: MAJOR.MINOR.PATCH
IFS='.' read -r MAJOR MINOR PATCH EXTRA <<EOF
$VERSION
EOF

if [ -n "$EXTRA" ] || [ -z "$MAJOR" ] || [ -z "$MINOR" ] || [ -z "$PATCH" ]; then
    echo "[version-hook] ERROR: Invalid version format in VERSION file: '$VERSION'"
    echo "[version-hook] Expected format: MAJOR.MINOR.PATCH (e.g., 1.2.3)"
    exit 1
fi

for part in "$MAJOR" "$MINOR" "$PATCH"; do
    case "$part" in
        *[!0-9]*)
            echo "[version-hook] ERROR: Invalid version format in VERSION file: '$VERSION'"
            echo "[version-hook] Expected format: MAJOR.MINOR.PATCH (e.g., 1.2.3)"
            exit 1
            ;;
    esac
done

# Resolve highest baseline version between:
# 1) current VERSION file,
# 2) previous branch VERSION (HEAD:VERSION),
# 3) existing semver tags.
BASE_VERSION="$VERSION"

PREV_BRANCH_VERSION=$(git show HEAD:VERSION 2>/dev/null | tr -d '[:space:]')
if [ -n "$PREV_BRANCH_VERSION" ] && is_valid_semver "$PREV_BRANCH_VERSION" && version_gt "$PREV_BRANCH_VERSION" "$BASE_VERSION"; then
    BASE_VERSION="$PREV_BRANCH_VERSION"
fi

LATEST_TAG=$(git tag --list | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)
if [ -n "$LATEST_TAG" ] && version_gt "$LATEST_TAG" "$BASE_VERSION"; then
    BASE_VERSION="$LATEST_TAG"
fi

IFS='.' read -r MAJOR MINOR PATCH EXTRA <<EOF
$BASE_VERSION
EOF

# Increment patch version
PATCH=$((PATCH + 1))
NEW_VERSION="$MAJOR.$MINOR.$PATCH"

# Write new version
echo "$NEW_VERSION" > "$VERSION_FILE"

# Stage the updated VERSION file
git add "$VERSION_FILE"

echo "[version-hook] Version: $BASE_VERSION -> $NEW_VERSION (file had $VERSION)"
